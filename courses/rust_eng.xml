<?xml version="1.0" encoding="UTF-8"?>
<course>
    <title>Rust Programming</title>
    <img src="img/rust_eng.png" alt="Rust Programming"/>
    <sections>
        <section id="1">
            <title>Introduction to Rust</title>
            <topics>
                <topic id="1">
                    <title>What is Rust?</title>
                    <content>Rust is a systems programming language that was initially developed by Mozilla Research, with version 1.0 released in 2015. Created by Graydon Hoare and later developed by the Rust team, it addresses many of the challenges developers face with lower-level languages like C and C++. Rust is designed from the ground up to provide memory safety without sacrificing performance.

Unlike many other programming languages, Rust enforces memory safety through its unique ownership system. This means that Rust programs cannot experience crashes from dangling pointers, buffer overflows, or other memory-related errors that plague C and C++ applications. The compiler catches these issues at compile time rather than at runtime, providing both safety and efficiency.

Rust excels in situations where high performance is crucial. It achieves speeds comparable to C and C++ while providing modern language features like pattern matching, type inference, and zero-cost abstractions. This makes Rust suitable for performance-critical applications such as game engines, operating systems, browser components, and embedded systems.

One of Rust's standout features is its concurrency model. The ownership system and type checking help prevent data races and other concurrency bugs at compile time. This means you can write multi-threaded code with confidence that it won't have the common pitfalls of concurrent programming.

The Rust ecosystem is growing rapidly, with a package manager called Cargo and a repository of community packages called crates.io. Major companies like Microsoft, Google, Amazon, and Dropbox have adopted Rust for various projects. Mozilla used Rust to develop Servo, an experimental browser engine that influenced Firefox. Amazon Web Services uses Rust for performance-critical components, and Microsoft has been exploring Rust for systems programming to improve security.

Rust has a steep learning curve compared to languages like Python, primarily because of its ownership model and strict compiler. However, this investment pays off with highly reliable and efficient code. The compiler provides detailed error messages that guide you toward fixing problems, making the learning process more manageable.

The Rust community prides itself on being welcoming and helpful. The official documentation, known as "The Book," is comprehensive and freely available online. There are also active forums, a dedicated subreddit, and many Discord channels where beginners can get help.</content>
                </topic>
                <topic id="1">
                    <title>Setting Up Rust</title>
                    <content>Installing Rust on your computer is straightforward thanks to rustup, the official Rust toolchain installer. This tool manages the complete Rust development environment, regardless of your operating system.

For Windows users:
1. Visit the official Rust website (https://www.rust-lang.org/tools/install)
2. Download the rustup-init.exe file
3. Run the installer
4. Follow the on-screen instructions, accepting the defaults for a standard installation
5. Restart your command prompt after installation

When installing Rust on Windows, you might need the Microsoft C++ build tools. If the installer detects they're missing, it will provide instructions for installing them. After installation, open Command Prompt or PowerShell and verify your installation with these commands:

rustc --version
cargo --version


For macOS and Linux users, installation is typically done through the terminal:
1. Open a terminal window
2. Run the following command:
   
   curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
   
3. Follow the prompts, choosing the default installation option
4. Run `source $HOME/.cargo/env` or restart your terminal

The Rust installation includes several important components:
- `rustc`: The Rust compiler that turns your Rust code into executable programs
- `cargo`: The package manager and build system for Rust projects
- `rustup`: The toolchain installer itself, which lets you manage Rust versions
- Standard library documentation that you can access offline

After installing Rust, you should familiarize yourself with Cargo's project management capabilities. To create a new project, you can use:

cargo new my_project


This creates a new directory with a basic project structure, including a `Cargo.toml` file (similar to Python's requirements.txt) and a src directory with a main.rs file.

Common issues you might encounter during installation:
- Path issues: Make sure Rust binaries are in your system PATH
- Permission problems: You might need administrator rights on Windows or `sudo` on Unix-based systems
- Network issues: Ensure you have a stable internet connection during installation
- Toolchain conflicts: If you're developing with multiple Rust versions, learn to use `rustup` to switch between them

For managing dependencies in your projects, Cargo makes it simple to add external libraries. Just edit your `Cargo.toml` file to add dependencies, and then run `cargo build` to download and compile them.

Unlike Python's virtual environments, Rust handles dependencies at the project level through Cargo. Each project has its own `Cargo.toml` file specifying its dependencies, and Cargo ensures they're properly managed without conflicting with other projects.</content>
                </topic>
                <topic id="1">
                    <title>Rust's Ecosystem and Community</title>
                    <content>The Rust ecosystem has grown significantly since the language's stable release, providing developers with a robust collection of tools, libraries, and resources. Understanding this ecosystem is crucial for becoming an effective Rust programmer.

At the center of Rust's ecosystem is Cargo, Rust's package manager and build system. Cargo handles dependency management, compilation, testing, documentation generation, and even publishing your own packages. Unlike package managers in some other languages, Cargo integrates deeply with Rust's development workflow:

cargo build    # Compile your project
cargo run      # Run your program
cargo test     # Run tests
cargo doc      # Generate documentation
cargo publish  # Share your library on crates.io


Crates.io is Rust's central package registry where developers share open-source libraries (called "crates"). As of 2024, it hosts over 100,000 packages covering areas from web development to embedded systems. Some of the most popular crates include:
- serde: For serialization and deserialization
- tokio: An asynchronous runtime for network applications
- actix-web: A powerful web framework
- diesel: An ORM and query builder
- rocket: A web framework focused on ease-of-use
- rayon: For parallel computation

The Rust standard library is intentionally minimal, focusing on core functionality rather than providing solutions for every use case. This design philosophy encourages a vibrant ecosystem of specialized, well-maintained crates that users can choose based on their specific needs.

Rust's documentation ecosystem is exceptional. Every project built with Cargo can generate professional-quality documentation with a simple command. This documentation includes:
- Function signatures and descriptions
- Examples that are automatically tested
- Module relationships and type hierarchies
- Searchable indexes and cross-references

Beyond code and documentation, Rust has developed a strong community known for being welcoming and helpful. Key community resources include:
- The Rust Programming Language book (affectionately called "The Book"): The official beginner's guide
- Rust by Example: A collection of runnable examples demonstrating Rust concepts
- This Week in Rust: A weekly newsletter summarizing developments in the Rust world
- The Rustlings course: Interactive exercises to learn Rust
- The Rust Forum and r/rust subreddit: Places to ask questions and discuss Rust topics

Rust development is guided by teams focusing on different aspects of the language and ecosystem. These teams work openly, discussing proposals through Request for Comments (RFCs) where community members can participate. This governance model ensures Rust evolves in ways that benefit its users rather than following a single company's agenda.

The Rust Foundation, established in 2021, provides organizational and financial support for Rust development. Its members include major technology companies like Google, Microsoft, AWS, and Mozilla, demonstrating industry confidence in Rust's future.

For beginners, Rust's ecosystem might seem overwhelming, but there are clear entry points:
1. Start with "The Book" to learn core concepts
2. Use the Rustlings course for hands-on practice
3. Build small projects using popular crates
4. Join the Rust Discord server or forum to get help when needed
5. Explore the "Awesome Rust" GitHub repository for curated lists of quality resources

The Rust community puts strong emphasis on code quality and maintenance. Many popular crates follow semantic versioning strictly, provide comprehensive documentation, and maintain backward compatibility. This reliability makes Rust particularly suitable for production systems where stability is crucial.

Annual Rust surveys consistently show high satisfaction among users, with over 90% of respondents indicating they would use Rust again for their next project. This satisfaction stems from both the language itself and the supportive ecosystem surrounding it.

As you delve deeper into Rust programming, engaging with this ecosystem will help you discover best practices, avoid common pitfalls, and become part of a community that values collaboration and technical excellence.</content>
                </topic>
            </topics>
        </section>
        <section id="2">
            <title>Basic Rust</title>
            <topics>
                <topic id="2">
                    <title>Variables and Data Types</title>
                    <content>Rust features a rich type system designed to provide safety and performance. Understanding Rust's variables and data types is fundamental to writing effective code.

Variables in Rust are immutable by default, which means once a value is assigned, it cannot be changed. This design choice enhances code safety and supports Rust's concurrency model:


let x = 5; // Immutable by default
// x = 10; // This would cause a compiler error

// To make a variable mutable, use the 'mut' keyword
let mut y = 5;
y = 10; // This works fine


When you need to shadow a variable (reuse its name with potentially different types), you can use the `let` keyword again:


let spaces = "   "; // This is a string
let spaces = spaces.len(); // Now spaces is a number


Rust's primitive types include:

Integer types with explicit sizes:
- Signed integers: `i8`, `i16`, `i32`, `i64`, `i128`, `isize` (architecture-dependent)
- Unsigned integers: `u8`, `u16`, `u32`, `u64`, `u128`, `usize` (architecture-dependent)
- Default integer type is `i32`, which offers a good balance of speed and range

Floating-point types:
- `f32` (single precision)
- `f64` (double precision, default)

Boolean type:
- `bool` with values `true` and `false`

Character type:
- `char` represents a Unicode scalar value using single quotes
- Example: `let c = 'z';`

Compound types in Rust include:

Tuples - fixed-length collections of related values that can have different types:

let coordinates = (10.5, 20.8);
let (x, y) = coordinates; // Destructuring
let latitude = coordinates.0; // Accessing by index


Arrays - fixed-length collections of elements of the same type:

let months = ["January", "February", "March"];
let first_month = months[0];
let numbers: [i32; 5] = [1, 2, 3, 4, 5]; // Explicit type and size
let zeros = [0; 10]; // Creates [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]


Strings - Rust has two main string types:
- String slices (`&#38;str`): immutable references to string data
- `String`: a growable, heap-allocated string type

let string_slice = "Hello"; // &#38;str type
let owned_string = String::from("World"); // String type
let combined = format!("{} {}", string_slice, owned_string);


Rust also supports type conversion through:
- Implicit coercion in limited contexts
- Explicit casting with the `as` keyword

let decimal = 65.4321;
let integer = decimal as u8; // Explicit cast to u8


When defining variables, type annotations are optional in most cases due to Rust's type inference, but can be added for clarity:

let inferred_type = 5; // Compiler infers i32
let explicit_type: u32 = 5; // Explicitly typed as u32


Constants must have their type declared and are defined using the `const` keyword:

const MAX_POINTS: u32 = 100_000; // Underscores for readability


Understanding Rust's type system helps prevent common programming errors at compile time rather than runtime, which is a core benefit of the language. The strictness may feel constraining at first, but it leads to more robust and predictable code.</content>
                </topic>
                <topic id="2">
                    <title>Operators and Expressions</title>
                    <content>Operators in Rust provide ways to perform calculations, compare values, and build logical expressions. Rust expressions evaluate to a value and form the building blocks of Rust code.

Arithmetic operators work with numeric types:

let sum = 5 + 10;
let difference = 95.5 - 4.3;
let product = 4 * 30;
let quotient = 56.7 / 32.2; // Division
let remainder = 43 % 5;     // Modulo/remainder


Comparison operators return boolean values:

let is_equal = 10 == 10;        // true
let is_not_equal = 3 != 5;      // true
let is_greater = 20 > 5;        // true
let is_less = 5 &lt; 10;           // true
let is_greater_equal = 10 >= 10; // true
let is_less_equal = 5 &lt;= 10;    // true


Logical operators combine boolean expressions:

let condition1 = true;
let condition2 = false;

let both = condition1 &#38;&#38; condition2; // Logical AND
let either = condition1 || condition2; // Logical OR
let not_cond = !condition1;         // Logical NOT


Bitwise operators manipulate individual bits in integer types:

let bitwise_and = 0b1010 &#38; 0b1100;    // 0b1000 (8 in decimal)
let bitwise_or = 0b1010 | 0b1100;     // 0b1110 (14 in decimal)
let bitwise_xor = 0b1010 ^ 0b1100;    // 0b0110 (6 in decimal)
let left_shift = 0b0010 &lt;&lt; 2;         // 0b1000 (8 in decimal)
let right_shift = 0b1000 >> 1;        // 0b0100 (4 in decimal)


Assignment operators combine an operation with assignment:

let mut value = 5;
value += 10;  // Equivalent to: value = value + 10
value -= 3;   // Equivalent to: value = value - 3
value *= 2;   // Equivalent to: value = value * 2
value /= 3;   // Equivalent to: value = value / 3
value %= 4;   // Equivalent to: value = value % 4


Rust uses expressions extensively. Unlike many other languages, most constructs in Rust are expressions that return values:

If expressions return the value of the executed branch:

let condition = true;
let number = if condition { 5 } else { 6 };
// number will be 5


Block expressions evaluate to the last expression in the block:

let result = {
    let x = 3;
    let y = 4;
    x + y  // Note: no semicolon means this value is returned
};
// result will be 7


Match expressions provide powerful pattern matching:

let dice_roll = 6;
let result = match dice_roll {
    1 => "Critical failure",
    2..=5 => "Common result",
    6 => "Critical success",
    _ => "Invalid roll",
};
// result will be "Critical success"


Range expressions create iterators:

for i in 1..5 {  // Exclusive range (1, 2, 3, 4)
    println!("Value: {}", i);
}

for i in 1..=5 { // Inclusive range (1, 2, 3, 4, 5)
    println!("Value: {}", i);
}


Rust's expression-oriented nature makes code more concise and encourages a functional programming style. This approach, combined with Rust's powerful type system, results in code that's both expressive and safe.

Pattern matching is particularly powerful in Rust, going beyond simple switch statements found in other languages:

let pair = (0, -2);
match pair {
    (0, y) => println!("First is 0, second is {}", y),
    (x, 0) => println!("First is {}, second is 0", x),
    _ => println!("Neither value is 0"),
}


Understanding Rust's operators and expressions provides the foundation for writing clear, idiomatic Rust code that leverages the language's safety features while maintaining readability.</content>
                </topic>
                <topic id="2">
                    <title>Functions and Modules</title>
                    <content>Functions are the building blocks of reusable code in Rust, while modules provide organization and visibility control. Together, they enable well-structured programs.

Functions in Rust are defined using the `fn` keyword. Every Rust program has at least one function, the `main` function that serves as the entry point:


fn main() {
    println!("Hello, world!");
    
    // Call another function
    greet("Rustacean");
}

// Function with parameters
fn greet(name: &#38;str) {
    println!("Hello, {}!", name);
}


Functions can take parameters (with mandatory type annotations) and return values:

fn add(a: i32, b: i32) -> i32 {
    a + b  // No semicolon means this expression is returned
}

// Explicitly using return keyword (useful for early returns)
fn absolute_value(x: i32) -> i32 {
    if x >= 0 {
        return x;
    }
    -x
}


Rust functions can return multiple values using tuples:

fn calculate_statistics(numbers: &#38;[i32]) -> (i32, i32, i32) {
    let sum: i32 = numbers.iter().sum();
    let min = *numbers.iter().min().unwrap_or(&#38;0);
    let max = *numbers.iter().max().unwrap_or(&#38;0);
    
    (sum, min, max)
}

fn main() {
    let numbers = [10, 20, 30, 40, 50];
    let (sum, min, max) = calculate_statistics(&#38;numbers);
    println!("Sum: {}, Min: {}, Max: {}", sum, min, max);
}


Functions can be generic, working with different types:

fn largest&lt;T: PartialOrd>(list: &#38;[T]) -> &#38;T {
    let mut largest = &#38;list[0];
    
    for item in list {
        if item > largest {
            largest = item;
        }
    }
    
    largest
}


Rust organizes code using modules. Modules control privacy and provide namespaces for functions and types. You can define modules in several ways:

Inline module definition:

mod math {
    // Private function (only accessible within this module)
    fn square(x: i32) -> i32 {
        x * x
    }
    
    // Public function (accessible outside this module)
    pub fn double(x: i32) -> i32 {
        x * 2
    }
    
    // Nested module
    pub mod trigonometry {
        pub fn sin(x: f64) -> f64 {
            x.sin()
        }
    }
}

fn main() {
    // Access public function from module
    let doubled = math::double(5);
    
    // Access function from nested module
    let sine = math::trigonometry::sin(1.57);
}


Modules can also be defined in separate files. For a file structure like:

src/
├── main.rs
└── math.rs


In `math.rs`:

// Everything in this file belongs to the "math" module
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

pub fn subtract(a: i32, b: i32) -> i32 {
    a - b
}


In `main.rs`:

// Declare that we're using the math module from another file
mod math;

fn main() {
    let sum = math::add(10, 5);
    println!("Sum: {}", sum);
}


Rust also supports the use of `use` statements to bring items into scope:

mod shapes {
    pub struct Rectangle {
        pub width: f64,
        pub height: f64,
    }
    
    impl Rectangle {
        pub fn area(&#38;self) -> f64 {
            self.width * self.height
        }
    }
}

// Bring Rectangle into scope
use shapes::Rectangle;

fn main() {
    let rect = Rectangle {
        width: 10.0,
        height: 5.0,
    };
    
    println!("Area: {}", rect.area());
}


For larger projects, Rust uses crates as compilation units. A crate can be a binary (executable) or a library. Projects are managed with Cargo, which handles dependencies specified in the `Cargo.toml` file:

toml
[package]
name = "my_project"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = "1.0"
reqwest = "0.11"


External dependencies can then be used in your code:

// Bring external crate into scope
use reqwest;
use serde::Deserialize;

#[derive(Deserialize)]
struct User {
    name: String,
    email: String,
}

async fn get_user() -> Result&lt;User, reqwest::Error> {
    let user: User = reqwest::get("https://api.example.com/user")
        .await?
        .json()
        .await?;
    
    Ok(user)
}


Rust's module system helps manage large codebases by:
- Preventing name conflicts with namespaces
- Encapsulating implementation details with privacy rules
- Enabling clear code organization with filesystem-based structure
- Supporting reusability through packages and crates

This organization system scales from small scripts to large, multi-crate projects, making Rust suitable for everything from simple tools to complex, performance-critical systems.</content>
                </topic>
            </topics>
        </section>
        <section id="3">
            <title>Control Structures</title>
            <topics>
                <topic id="3">
                    <title>Conditional Statements</title>
                    <content>Conditional statements in Rust help your program make decisions based on conditions. Unlike many other languages, if statements in Rust are expressions, which means they can return values.

Basic If Statements:

// Simple if statement
let age = 18;
if age >= 18 {
    println!("You are an adult");
}

// If-else statement
let temperature = 25;
if temperature > 30 {
    println!("It's hot today");
} else {
    println!("It's not too hot");
}

// If-else if-else (multiple conditions)
let score = 85;
if score >= 90 {
    println!("You got an A");
} else if score >= 80 {
    println!("You got a B");
} else if score >= 70 {
    println!("You got a C");
} else {
    println!("You need to study more");
}


If Expressions That Return Values:

let age = 20;
let status = if age >= 18 { "adult" } else { "minor" };
println!("Status: {}", status);  // Prints: Status: adult

// Calculating a value with if
let score = 85;
let grade = if score >= 90 { 'A' }
           else if score >= 80 { 'B' }
           else if score >= 70 { 'C' }
           else { 'F' };
println!("Grade: {}", grade);  // Prints: Grade: B


Note: When using if as an expression, all branches must return the same type.

Working with Multiple Conditions:

// Using &#38;&#38; (and)
let age = 25;
let has_license = true;
if age >= 18 &#38;&#38; has_license {
    println!("You can drive");
}

// Using || (or)
let is_weekend = true;
let is_holiday = false;
if is_weekend || is_holiday {
    println!("You can sleep late");
}

// Using ! (not)
let is_busy = false;
if !is_busy {
    println!("Let's go to the movies");
}


Real World Examples:

1. Simple Game Decision:

let player_health = 100;
let has_weapon = true;
let sees_enemy = true;

if player_health > 0 {
    if has_weapon &#38;&#38; sees_enemy {
        println!("Ready to fight!");
    } else if sees_enemy {
        println!("Run away!");
    } else {
        println!("Keep exploring");
    }
} else {
    println!("Game Over");
}


2. Shopping Discount:

let total_price = 100.0;
let is_member = true;
let is_sale_day = true;

let discount = if is_sale_day {
    if is_member { 20.0 } else { 10.0 }
} else {
    if is_member { 10.0 } else { 0.0 }
};

let final_price = total_price * (100.0 - discount) / 100.0;
println!("Final price: ${:.2}", final_price);


Common Mistakes to Avoid:

1. Forgetting Braces:

// Wrong - will not compile
if age >= 18
    println!("Adult");

// Right
if age >= 18 {
    println!("Adult");
}


2. Using Assignment Instead of Comparison:

// Wrong - will not compile in Rust
if age = 18 {
    println!("You're 18");
}

// Right
if age == 18 {
    println!("You're 18");
}


3. Mismatched Types in If Expressions:

// Wrong - mismatched types
let value = if condition { 5 } else { "five" };  // Error!

// Right - consistent types
let value = if condition { 5 } else { 10 };


Tips for Using If Statements in Rust:

1. Keep conditions simple and clear

// Hard to read
if age >= 18 &#38;&#38; has_license &#38;&#38; car_available &#38;&#38; !is_tired {
    println!("You can drive");
}

// Better - break it down
let can_legally_drive = age >= 18 &#38;&#38; has_license;
let car_is_ready = car_available &#38;&#38; !is_tired;

if can_legally_drive &#38;&#38; car_is_ready {
    println!("You can drive");
}


2. Use the expression form for cleaner code

// Verbose way
let message;
if score > 90 {
    message = "Excellent";
} else {
    message = "Good job";
}

// Better - use if as an expression
let message = if score > 90 { "Excellent" } else { "Good job" };


Remember:
1. Rust uses curly braces {} around the code blocks
2. Conditions don't need parentheses in Rust
3. All branches of an if expression must return the same type
4. You can use if expressions in let statements to assign values</content>
                </topic>
                <topic id="3">
                    <title>Loops and Iterators</title>
                    <content>Rust provides several loop constructs to help you repeat operations, with powerful iterator methods for processing collections efficiently.

Loop Types:

1. `loop` - Infinite Loop:

// Basic infinite loop with break
let mut counter = 0;
loop {
    println!("Count: {}", counter);
    counter += 1;
    if counter >= 5 {
        break;
    }
}

// Loop that returns a value
let result = loop {
    counter += 1;
    if counter == 10 {
        break counter * 2;  // Returns 20
    }
};
println!("Result: {}", result);


2. `while` - Conditional Loop:

// Count down from 5
let mut count = 5;
while count > 0 {
    println!("{}", count);
    count -= 1;
}
println!("Blast off!");


3. `for` - Iterating Over Collections:

// Iterate over a range
for i in 0..5 {
    println!("{}", i);  // Prints 0 to 4
}

// Iterate over a collection
let animals = vec!["Dog", "Cat", "Bird"];
for animal in animals.iter() {
    println!("Animal: {}", animal);
}

// Using enumerate() to get index and value
let fruits = vec!["Apple", "Banana", "Orange"];
for (index, fruit) in fruits.iter().enumerate() {
    println!("{}: {}", index, fruit);
}


Advanced Iterator Methods:

Rust's iterators offer many useful methods:


let numbers = vec![1, 2, 3, 4, 5];

// Map - transform each element
let doubled: Vec&lt;i32> = numbers.iter().map(|&#38;x| x * 2).collect();
println!("{:?}", doubled);  // [2, 4, 6, 8, 10]

// Filter - keep elements that match a condition
let even: Vec&lt;&#38;i32> = numbers.iter().filter(|&#38;&#38;x| x % 2 == 0).collect();
println!("{:?}", even);  // [2, 4]

// Find - get the first matching element
if let Some(&#38;first_even) = numbers.iter().find(|&#38;&#38;x| x % 2 == 0) {
    println!("First even number: {}", first_even);  // 2
}

// Fold - accumulate values
let sum: i32 = numbers.iter().fold(0, |acc, &#38;x| acc + x);
println!("Sum: {}", sum);  // 15


Real World Examples:

1. Processing a Collection:

struct User {
    name: String,
    age: u32,
    active: bool,
}

let users = vec![
    User { name: String::from("Alice"), age: 28, active: true },
    User { name: String::from("Bob"), age: 17, active: true },
    User { name: String::from("Charlie"), age: 32, active: false },
    User { name: String::from("Diana"), age: 22, active: true },
];

// Find all active adult users
let adult_active_users: Vec&lt;&#38;User> = users.iter()
    .filter(|user| user.age >= 18 &#38;&#38; user.active)
    .collect();

println!("Active adult users count: {}", adult_active_users.len());


Loop Labels:

Rust allows labeling loops, which is useful for breaking out of nested loops:


'outer: for x in 0..5 {
    for y in 0..5 {
        if x * y > 10 {
            println!("Breaking out at x={}, y={}", x, y);
            break 'outer;  // Breaks the outer loop
        }
        println!("({}, {})", x, y);
    }
}


Common Mistakes to Avoid:

1. Infinite Loops Without Break:

// Wrong - will run forever
loop {
    println!("This is infinite!");
}

// Better - has a way to end
let mut count = 0;
loop {
    println!("{}", count);
    count += 1;
    if count >= 5 {
        break;
    }
}


2. Not Using Iterators When Appropriate:

// Less idiomatic Rust
let numbers = vec![1, 2, 3, 4, 5];
let mut sum = 0;
for i in 0..numbers.len() {
    sum += numbers[i];
}

// More idiomatic Rust
let numbers = vec![1, 2, 3, 4, 5];
let sum: i32 = numbers.iter().sum();


3. Collecting Without Type Annotation:

// Wrong - missing type annotation
let doubled = numbers.iter().map(|&#38;x| x * 2).collect();  // Error!

// Right - with type annotation
let doubled: Vec&lt;i32> = numbers.iter().map(|&#38;x| x * 2).collect();


Tips for Using Loops and Iterators:

1. Choose the right loop for the job:
   - Use `loop` for infinite loops or when you need to return a value
   - Use `while` when you have a simple condition to check
   - Use `for` when iterating over collections

2. Prefer iterators over manual indexing:
   - They're more concise and expressive
   - They're often optimized by the compiler
   - They prevent common errors like off-by-one or out-of-bounds access

3. Chain iterator methods for complex operations:

let result: Vec&lt;i32> = numbers.iter()
    .filter(|&#38;&#38;x| x % 2 == 0)  // Keep even numbers
    .map(|&#38;x| x * 3)          // Multiply by 3
    .collect();               // Collect into a vector


Remember:
1. `loop` can return values when using `break expression;`
2. The range `0..5` excludes 5, while `0..=5` includes 5
3. Most iterator operations are lazy until you call `collect()` or a consuming operation
4. Use `iter()` to iterate over references, `into_iter()` to consume the collection</content>
                </topic>
                <topic id="3">
                    <title>Match Expressions</title>
                    <content>The match expression in Rust is a powerful control flow operator that allows pattern matching against values and ensures all possible cases are handled.

Basic Match Usage:

let number = 3;

match number {
    1 => println!("One!"),
    2 => println!("Two!"),
    3 => println!("Three!"),
    _ => println!("Something else!"),
}
// Prints: "Three!"


The `_` is a catch-all pattern that matches any value not specifically handled.

Match with Multiple Patterns:

let day = 3;

match day {
    1 | 2 | 3 | 4 | 5 => println!("Weekday"),
    6 | 7 => println!("Weekend"),
    _ => println!("Invalid day"),
}
// Prints: "Weekday"


Match with Ranges:

let score = 85;

match score {
    0..=59 => println!("F"),
    60..=69 => println!("D"),
    70..=79 => println!("C"),
    80..=89 => println!("B"),
    90..=100 => println!("A"),
    _ => println!("Invalid score"),
}
// Prints: "B"


Match with Destructuring:

enum Color {
    RGB(u8, u8, u8),
    HSV(u8, u8, u8),
    Name(String),
}

let color = Color::RGB(255, 0, 0);

match color {
    Color::RGB(255, 0, 0) => println!("This is pure red!"),
    Color::RGB(r, g, b) => println!("RGB color: {}, {}, {}", r, g, b),
    Color::HSV(h, s, v) => println!("HSV color: {}, {}, {}", h, s, v),
    Color::Name(name) => println!("Named color: {}", name),
}
// Prints: "This is pure red!"


Match with Guards:

let pair = (2, -2);

match pair {
    (x, y) if x == y => println!("Equal parts"),
    (x, y) if x + y == 0 => println!("Sum to zero"),
    (x, _) if x % 2 == 0 => println!("First is even"),
    _ => println!("No special case"),
}
// Prints: "Sum to zero"


Match that Returns Values:

let input = 'x';

let category = match input {
    'a'..='z' | 'A'..='Z' => "letter",
    '0'..='9' => "digit",
    ' ' | '\t' | '\n' => "whitespace",
    _ => "other",
};

println!("'{}' is a {}", input, category);
// Prints: "'x' is a letter"


Match with Option and Result:

Working with Option:

let maybe_value: Option&lt;i32> = Some(42);

match maybe_value {
    Some(value) => println!("Got a value: {}", value),
    None => println!("No value"),
}

// Shorthand with if let
if let Some(value) = maybe_value {
    println!("Got a value: {}", value);
}


Working with Result:

let result: Result&lt;i32, &#38;str> = Ok(200);

match result {
    Ok(value) => println!("Success: {}", value),
    Err(e) => println!("Error: {}", e),
}

// Shorthand with if let
if let Ok(value) = result {
    println!("Success: {}", value);
}


Real World Example - Error Handling:

use std::fs::File;
use std::io::ErrorKind;

fn open_file(path: &#38;str) {
    let result = File::open(path);
    
    match result {
        Ok(file) => {
            println!("File opened successfully: {:?}", file);
            // Process file...
        },
        Err(error) => match error.kind() {
            ErrorKind::NotFound => {
                println!("File not found, creating it...");
                match File::create(path) {
                    Ok(file) => println!("File created: {:?}", file),
                    Err(e) => println!("Failed to create file: {}", e),
                }
            },
            ErrorKind::PermissionDenied => {
                println!("Permission denied, check file permissions");
            },
            other_error => {
                println!("Other error: {:?}", other_error);
            }
        },
    }
}


Common Mistakes to Avoid:

1. Forgetting the Catch-All Pattern:

// Wrong - not handling all cases (won't compile)
match number {
    1 => println!("One"),
    2 => println!("Two"),
}

// Right - handling all cases
match number {
    1 => println!("One"),
    2 => println!("Two"),
    _ => println!("Other number"),
}


2. Unreachable Patterns:

// Wrong - unreachable pattern (won't compile)
match number {
    n if n > 0 => println!("Positive"),
    _ => println!("Non-positive"),
    5 => println!("Five"),  // This will never be reached
}

// Right - patterns in correct order
match number {
    5 => println!("Five"),
    n if n > 0 => println!("Positive"),
    _ => println!("Non-positive"),
}


Tips for Using Match:

1. Use `match` when you need to handle multiple possible values or patterns.

2. Remember that `match` is exhaustive - you must handle all possible cases.

3. For simple matching against a single pattern, consider using `if let`:

// With match
match some_option {
    Some(value) => println!("Got {}", value),
    None => (),  // Do nothing
}

// With if let (more concise)
if let Some(value) = some_option {
    println!("Got {}", value);
}


4. Use the `@` binding to both test a value and bind it:

match temperature {
    t @ 0..=32 => println!("Freezing at {}°F", t),
    t @ 33..=65 => println!("Cold at {}°F", t),
    t @ 66..=80 => println!("Comfortable at {}°F", t),
    t => println!("Warm at {}°F", t),
}


Remember:
1. Match is exhaustive - you must cover all possible values
2. Patterns are checked in order from top to bottom
3. Use `_` as a catch-all pattern for values you don't need to use
4. Match arms can contain blocks with multiple statements
5. Match expressions can return values that can be assigned to variables</content>
                </topic>
            </topics>
        </section>
        <section id="4">
            <title>Ownership and Borrowing</title>
            <topics>
                <topic id="4">
                    <title>Ownership Rules</title>
                    <content>Rust's ownership system ensures memory safety and prevents data races without needing a garbage collector. Every value in Rust has a single owner, and when the owner goes out of scope, Rust automatically deallocates the memory.

Key Rules of Ownership:
1. Each value in Rust has a single owner.
2. When the owner goes out of scope, the value is dropped.
3. Ownership can be transferred (moved) but cannot be shared unless explicitly borrowed.

Example:

fn main() {
    let s1 = String::from("Hello");
    let s2 = s1; // Ownership moves to s2, s1 is no longer valid
    // println!("{}", s1); // Error: value borrowed after move
}


Copy Trait:
Some types implement the `Copy` trait, meaning they can be duplicated rather than moved.

fn main() {
    let x = 5;
    let y = x; // x is still valid because integers implement Copy
    println!("{}", x);
}


Common Ownership Mistakes:
- Trying to use a value after moving it
- Forgetting that non-Copy types cannot be reassigned after a move</content>
                </topic>
                <topic id="4">
                    <title>References and Borrowing</title>
                    <content>Borrowing allows references to be used without transferring ownership. Rust enforces strict borrowing rules to ensure safety.

Borrowing Rules:
1. You can have multiple immutable references (`&#38;T`).
2. You can have only one mutable reference (`&#38;mut T`) at a time.
3. References must always be valid.

Example:

fn main() {
    let s = String::from("Hello");
    print_length(&#38;s); // Borrowing s without transferring ownership
    println!("{}", s); // s is still valid
}

fn print_length(s: &#38;String) {
    println!("Length: {}", s.len());
}


Mutable Borrowing:

fn main() {
    let mut s = String::from("Hello");
    change(&#38;mut s);
    println!("{}", s);
}

fn change(s: &#38;mut String) {
    s.push_str(", world!");
}


Common Borrowing Mistakes:
- Trying to have a mutable and immutable reference at the same time
- Holding a reference beyond its lifetime</content>
                </topic>
                <topic id="4">
                    <title>Lifetimes</title>
                    <content>Lifetimes ensure references are valid for the duration they are used, preventing dangling pointers.

Understanding Lifetimes:
Rust requires explicit lifetime annotations when references are used in function parameters.

fn longest&lt;'a>(s1: &#38;'a str, s2: &#38;'a str) -> &#38;'a str {
    if s1.len() > s2.len() {
        s1
    } else {
        s2
    }
}


Lifetimes in Structs:

struct Book&lt;'a> {
    title: &#38;'a str,
}

fn main() {
    let title = String::from("Rust Programming");
    let book = Book { title: &#38;title };
    println!("{}", book.title);
}


Common Lifetime Mistakes:
- Returning references to local variables (dangling references)
- Forgetting to specify lifetimes in structs or functions</content>
                </topic>
            </topics>
        </section>
        <section id="5">
            <title>Advanced Topics</title>
            <topics>
                <topic id="5">
                    <title>Concurrency and Threads</title>
                    <content>Rust provides robust support for concurrency, ensuring that multiple tasks can run simultaneously without causing issues like data races. It leverages tools such as mutexes, atomic types, and the Send and Sync traits to enforce safety at compile time.

Key Concepts in Rust Concurrency:
1. Mutexes: A Mutex (short for mutual exclusion) ensures that only one thread can access data at a time, preventing race conditions.
    
    use std::sync::{Arc, Mutex};
    use std::thread;

    let counter = Arc::new(Mutex::new(0));

    let handles: Vec&#38;_> = (0..10).map(|_| {
        let counter = Arc::clone(&#38;counter);
        thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        })
    }).collect();

    for handle in handles {
        handle.join().unwrap();
    }
    println!("Result: {}", *counter.lock().unwrap());
    

2. Atomic Types: These types (like `AtomicBool`, `AtomicI32`) allow for lock-free atomic operations and are useful for shared data across threads.
    
    use std::sync::atomic::{AtomicUsize, Ordering};
    use std::thread;

    let counter = AtomicUsize::new(0);

    let handles: Vec&lt;_> = (0..10).map(|_| {
        thread::spawn(|| {
            counter.fetch_add(1, Ordering::SeqCst);
        })
    }).collect();

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", counter.load(Ordering::SeqCst));
    

3. Send and Sync Traits: These traits indicate whether a type can be safely transferred across threads (Send) or shared safely between threads (Sync).
    - `Send`: Types that can be moved between threads.
    - `Sync`: Types that can be accessed concurrently by multiple threads.

Important Considerations:
- Ownership: Rust’s ownership system ensures that data is either owned by a single thread or shared safely.
- Deadlock: A deadlock can occur when two threads are waiting for each other to release resources. Careful design can avoid this.

Related Topics:
- Parallelism in Rust
- Thread pools
- Channel-based communication between threads</content>
                </topic>
                <topic id="5">
                    <title>Error Handling</title>
                    <content>Rust uses a unique and powerful error handling model that involves the `Result` and `Option` types. This approach encourages developers to explicitly handle errors, leading to more reliable and predictable programs.

Basic Error Handling with `Result`:
- The `Result` type is used for functions that can either succeed (`Ok`) or fail (`Err`).
    
    fn divide(a: i32, b: i32) -> Result&lt;i32, String> {
        if b == 0 {
            Err("Cannot divide by zero".to_string())
        } else {
            Ok(a / b)
        }
    }

    let result = divide(10, 2);
    match result {
        Ok(value) => println!("Result: {}", value),
        Err(e) => println!("Error: {}", e),
    }
    

Error Propagation with `?`:
- Rust provides the `?` operator for propagating errors easily, reducing boilerplate.
    
    fn read_file(path: &#38;str) -> Result&lt;String, std::io::Error> {
        let content = std::fs::read_to_string(path)?;
        Ok(content)
    }
    

Common Errors:
- `Option`: Used for cases where a value may or may not be present (e.g., `None` vs `Some`).
    
    fn get_username() -> Option&lt;String> {
        Some("Alice".to_string()) // Or None if not found
    }

    match get_username() {
        Some(name) => println!("Found user: {}", name),
        None => println!("No user found"),
    }
    

Creating Custom Errors:
Rust also allows you to define custom error types to handle application-specific errors:

use std::fmt;

#[derive(Debug)]
enum MyError {
    NotFound,
    InvalidInput,
}

impl fmt::Display for MyError {
    fn fmt(&#38;self, f: &#38;mut fmt::Formatter&lt;'_>) -> fmt::Result {
        match self {
            MyError::NotFound => write!(f, "Item not found"),
            MyError::InvalidInput => write!(f, "Invalid input"),
        }
    }
}


Important Things to Remember:
- Always handle `Result` and `Option` types explicitly.
- The `?` operator is great for propagating errors up the call stack.
- The `match` expression is a powerful tool for exhaustive error handling.

Related Topics:
- `unwrap` and `expect` methods (used for quick error handling)
- The `Error` trait and custom error types
- Rust’s pattern matching in error handling</content>
                </topic>
                <topic id="5">
                    <title>Unsafe Rust</title>
                    <content>Unsafe Rust allows developers to write code that can bypass some of Rust’s strict safety rules, but with great power comes great responsibility. Unsafe code can interact directly with raw pointers, and Rust provides a way to define clear boundaries around unsafe blocks of code.

What is Unsafe Rust?
- Unsafe code can do things like dereference raw pointers or call functions that the compiler cannot verify. It is marked with the `unsafe` keyword, signaling that the developer takes responsibility for ensuring memory safety.
    
    let x: i32 = 42;
    let r: *const i32 = &#38;x;

    unsafe {
        println!("Dereferenced pointer: {}", *r); // Unsafe operation
    }
    

Common Uses of Unsafe Rust:
1. Working with raw pointers: Rust typically ensures safe memory access through its ownership system. Unsafe code can manually manage memory and access locations that are normally not accessible.
    
    let x: i32 = 42;
    let r: *const i32 = &#38;x;
    
    unsafe {
        let y = *r; // Dereferencing a raw pointer is unsafe
    }
    

2. FFI (Foreign Function Interface): Rust allows you to call functions written in other languages (like C) through unsafe code. This is commonly used when interfacing with low-level system APIs or libraries.
    
    extern "C" {
        fn c_function(arg: i32) -> i32;
    }
    

Why Use Unsafe Rust?
- Unsafe Rust can be useful when you need to write low-level code or interface with hardware or other languages. It allows for optimizations and operations that are not possible with safe Rust.
- However, it's crucial to ensure that the unsafe code doesn't violate memory safety rules, as doing so can lead to undefined behavior, memory corruption, and crashes.

Important Considerations:
- The use of unsafe should be minimized and clearly documented.
- Rust’s ownership system and lifetime tracking are turned off inside unsafe blocks, so the developer must manually handle memory safety.

Related Topics:
- Using the `unsafe` keyword
- Memory management in Rust
- Interfacing with C and other languages via FFI</content>
                </topic>
            </topics>
        </section>
    </sections>
</course>